
==================== FINAL INTERFACE ====================
2017-08-13 00:09:03.5495277 UTC

interface simple-cipher-0.1.0.2-1cDc6mPfSu2AX29xSa9l7p:Cipher 8002
  interface hash: 18b23d4feb38e22343a497ad80656be1
  ABI hash: 3bc248b6c65951c13ad2defbb5541873
  export-list hash: d716e653bdd97648bcd5f712c0895640
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 50be09f6ae5701bb586bc6db9bc9ce26
  sig of: Nothing
  used TH splices: False
  where
exports:
  Cipher.caesarDecode
  Cipher.caesarEncode
  Cipher.caesarEncodeRandom
module dependencies:
package dependencies: Win32-2.3.1.1@Win32-2.3.1.1
                      array-0.5.1.1@array-0.5.1.1 base-4.9.1.0*
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1 random-1.1@random-1.1-9tceXaeYIMZ4JrKq20Egog*
                      time-1.6.0.1@time-1.6.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         time-1.6.0.1@time-1.6.0.1:Data.Time.Calendar.Gregorian
         time-1.6.0.1@time-1.6.0.1:Data.Time.Format.Parse
         time-1.6.0.1@time-1.6.0.1:Data.Time.LocalTime.LocalTime
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:Data.Char c49b58282af11503cc838e1052cf6b83
import  -/  base-4.9.1.0:Data.Foldable 254e836c2d813d34e47feb29bb8d40ed
import  -/  base-4.9.1.0:Data.List 7349774f430841349c90dfd1144aea97
import  -/  base-4.9.1.0:Data.Maybe ecf0c6f81372d9b58b142d5e758ea51b
import  -/  base-4.9.1.0:GHC.Base 4caea1123ecf4b46e27cbccd6d279377
import  -/  base-4.9.1.0:GHC.List d11eb227c1c6fbfd89bb781d72eaea0d
import  -/  base-4.9.1.0:GHC.Num 38b8aac8807c096c7f3ca3c1eff02939
import  -/  base-4.9.1.0:GHC.Real b88ae4a48c079652623073a5bbf5c9b0
import  -/  base-4.9.1.0:Prelude 74b3e204395920329f6de9d97206abe9
import  -/  ghc-prim-0.5.0.0:GHC.Classes 16d48e012d23eaef9bca91ccdd572c02
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
import  -/  random-1.1@random-1.1-9tceXaeYIMZ4JrKq20Egog:System.Random 4c90117f915e12291e0c5f588320bf66
33caea8e119c79b07f96979149035e71
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Cipher.$trModule2
                   Cipher.$trModule1) -}
e4414ced9d33bc149dd14b1e051a3e2d
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Cipher"#) -}
e3a8c0d4bfdad9fa7853e3eef5fd996c
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "simple-cipher-0.1.0.2-1cDc6mPfSu2AX29xSa9l7p"#) -}
37943a3492e52a84fa0f3416a268bdc2
  $wgo :: System.Random.StdGen -> GHC.Prim.Int# -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0] -}
36880ca6af2e003248c4a242eca789b7
  $wshiftCipherLeft ::
    GHC.Prim.Int# -> GHC.Types.Char -> GHC.Types.Char
  {- Arity: 2, Strictness: <S,U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (w :: GHC.Types.Char) ->
                 case GHC.List.lookup
                        @ GHC.Types.Char
                        @ GHC.Types.Int
                        GHC.Classes.$fEqChar
                        w
                        Cipher.alphabetList of wild {
                   GHC.Base.Nothing
                   -> case Data.Maybe.fromJust1 ret_ty GHC.Types.Char of {}
                   GHC.Base.Just x
                   -> case x of wild1 { GHC.Types.I# x1 ->
                      let {
                        x2 :: GHC.Prim.Int# = GHC.Prim.-# x1 ww
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x2 0#) of wild2 {
                        GHC.Types.False
                        -> case GHC.List.lookup
                                  @ GHC.Types.Int
                                  @ GHC.Types.Char
                                  GHC.Classes.$fEqInt
                                  (GHC.Types.I# (GHC.Prim.+# 26# x2))
                                  Cipher.alphabetListByValue of wild3 {
                             GHC.Base.Nothing -> Data.Maybe.fromJust1 @ GHC.Types.Char
                             GHC.Base.Just x3 -> x3 }
                        GHC.Types.True
                        -> case GHC.List.lookup
                                  @ GHC.Types.Int
                                  @ GHC.Types.Char
                                  GHC.Classes.$fEqInt
                                  (GHC.Types.I# x2)
                                  Cipher.alphabetListByValue of wild3 {
                             GHC.Base.Nothing -> Data.Maybe.fromJust1 @ GHC.Types.Char
                             GHC.Base.Just x3 -> x3 } } } }) -}
0383408583c8f42dd4c1e8ea911c0015
  $wshiftCipherRight ::
    GHC.Prim.Int# -> GHC.Types.Char -> GHC.Types.Char
  {- Arity: 2, Strictness: <S,U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (w :: GHC.Types.Char) ->
                 case GHC.List.lookup
                        @ GHC.Types.Char
                        @ GHC.Types.Int
                        GHC.Classes.$fEqChar
                        w
                        Cipher.alphabetList of wild {
                   GHC.Base.Nothing
                   -> case Data.Maybe.fromJust1 ret_ty GHC.Types.Char of {}
                   GHC.Base.Just x
                   -> case x of wild1 { GHC.Types.I# x1 ->
                      let {
                        x2 :: GHC.Prim.Int# = GHC.Prim.+# x1 ww
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# x2 25#) of wild2 {
                        GHC.Types.False
                        -> case GHC.List.lookup
                                  @ GHC.Types.Int
                                  @ GHC.Types.Char
                                  GHC.Classes.$fEqInt
                                  (case GHC.Classes.modInt# x2 25# of ww2 { DEFAULT ->
                                   GHC.Types.I# (GHC.Prim.-# ww2 1#) })
                                  Cipher.alphabetListByValue of wild3 {
                             GHC.Base.Nothing -> Data.Maybe.fromJust1 @ GHC.Types.Char
                             GHC.Base.Just x3 -> x3 }
                        GHC.Types.True
                        -> case GHC.List.lookup
                                  @ GHC.Types.Int
                                  @ GHC.Types.Char
                                  GHC.Classes.$fEqInt
                                  (GHC.Types.I# x2)
                                  Cipher.alphabetListByValue of wild3 {
                             GHC.Base.Nothing -> Data.Maybe.fromJust1 @ GHC.Types.Char
                             GHC.Base.Just x3 -> x3 } } } }) -}
59cae9e529764ebcf84e21f94db40c32
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
737ccff9dbe7fc60489a17f6091e7d8c
  alphabetList :: [(GHC.Types.Char, GHC.Types.Int)]
  {- Unfolding: (Cipher.caesarDecode_go2 97# Cipher.caesarDecode2) -}
ca91eae70b010e5b698ac37f516409b7
  alphabetListByValue :: [(GHC.Types.Int, GHC.Types.Char)]
  {- Unfolding: (Cipher.caesarDecode_go1 0# Cipher.caesarDecode1) -}
6497cabe75a3d250b94d172ee1aefc74
  caesarDecode ::
    GHC.Base.String -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: (\ (key :: GHC.Base.String)
                   (encodedText :: GHC.Base.String) ->
                 case GHC.List.$wlenAcc
                        @ GHC.Types.Char
                        encodedText
                        0# of ww2 { DEFAULT ->
                 let {
                   ww :: GHC.Prim.Int# = GHC.Prim.-# ww2 1#
                 } in
                 let {
                   $j :: GHC.Prim.Void# -> [GHC.Types.Char] {- Arity: 1 -}
                   = \ (w :: GHC.Prim.Void#)[OneShot] ->
                     let {
                       lvl2 :: GHC.Base.Maybe GHC.Types.Int
                       = GHC.List.lookup
                           @ GHC.Types.Char
                           @ GHC.Types.Int
                           GHC.Classes.$fEqChar
                           (case key of wild {
                              [] -> GHC.List.badHead @ GHC.Types.Char : x ds1 -> x })
                           Cipher.alphabetList
                     } in
                     letrec {
                       xs :: [GHC.Types.Char] -> [GHC.Types.Char]
                         {- Arity: 1, Strictness: <S,1*U> -}
                       = \ (ds :: [GHC.Types.Char]) ->
                         case ds of wild {
                           [] -> GHC.Types.[] @ GHC.Types.Char
                           : y ys
                           -> GHC.Types.:
                                @ GHC.Types.Char
                                (case lvl2 of wild1 {
                                   GHC.Base.Nothing
                                   -> case Data.Maybe.fromJust1 ret_ty GHC.Types.Char of {}
                                   GHC.Base.Just x
                                   -> case x of ww1 { GHC.Types.I# ww3 ->
                                      Cipher.$wshiftCipherLeft ww3 y } })
                                (xs ys) }
                     } in
                     xs encodedText
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww 0#) of wild {
                   GHC.Types.False
                   -> case Cipher.$wunsafeDrop @ GHC.Types.Char ww key of wild1 {
                        [] -> $j GHC.Prim.void#
                        : ipv ipv1 -> Cipher.caesarDecode_go key encodedText }
                   GHC.Types.True
                   -> case key of wild1 {
                        [] -> $j GHC.Prim.void#
                        : ipv ipv1 -> Cipher.caesarDecode_go wild1 encodedText } } }) -}
3e54b25986ad811ea4cf0ce8dbc4f255
  caesarDecode1 :: GHC.Base.String
  {- Unfolding: (GHC.Enum.eftChar 97# 122#) -}
019c20fe4eccc595e0dc94bc31f8e3f5
  caesarDecode2 :: [GHC.Types.Int]
  {- Unfolding: (GHC.Enum.eftInt 0# 25#) -}
7eecb20e1820072042f3a1f85fe3b71a
  caesarDecode_go ::
    [GHC.Types.Char] -> [GHC.Types.Char] -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
ad7b60f672c60a5cec6069ad0a6bfcde
  caesarDecode_go1 ::
    GHC.Prim.Int#
    -> [GHC.Types.Char] -> [(GHC.Types.Int, GHC.Types.Char)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
0b0cf345ac1b0181871909f4c38db930
  caesarDecode_go2 ::
    GHC.Prim.Int#
    -> [GHC.Types.Int] -> [(GHC.Types.Char, GHC.Types.Int)]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,1*U> -}
5d6d42f1030675d5fe32408fc91df71c
  caesarEncode ::
    GHC.Base.String -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: (\ (key :: GHC.Base.String) (text :: GHC.Base.String) ->
                 case GHC.List.$wlenAcc @ GHC.Types.Char text 0# of ww2 { DEFAULT ->
                 let {
                   ww :: GHC.Prim.Int# = GHC.Prim.-# ww2 1#
                 } in
                 let {
                   $j :: GHC.Prim.Void# -> [GHC.Types.Char] {- Arity: 1 -}
                   = \ (w :: GHC.Prim.Void#)[OneShot] ->
                     let {
                       lvl2 :: GHC.Base.Maybe GHC.Types.Int
                       = GHC.List.lookup
                           @ GHC.Types.Char
                           @ GHC.Types.Int
                           GHC.Classes.$fEqChar
                           (case key of wild {
                              [] -> GHC.List.badHead @ GHC.Types.Char : x ds1 -> x })
                           Cipher.alphabetList
                     } in
                     letrec {
                       xs :: [GHC.Types.Char] -> [GHC.Types.Char]
                         {- Arity: 1, Strictness: <S,1*U> -}
                       = \ (ds :: [GHC.Types.Char]) ->
                         case ds of wild {
                           [] -> GHC.Types.[] @ GHC.Types.Char
                           : y ys
                           -> GHC.Types.:
                                @ GHC.Types.Char
                                (case lvl2 of wild1 {
                                   GHC.Base.Nothing
                                   -> case Data.Maybe.fromJust1 ret_ty GHC.Types.Char of {}
                                   GHC.Base.Just x
                                   -> case x of ww1 { GHC.Types.I# ww3 ->
                                      Cipher.$wshiftCipherRight ww3 y } })
                                (xs ys) }
                     } in
                     xs text
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww 0#) of wild {
                   GHC.Types.False
                   -> case Cipher.$wunsafeDrop @ GHC.Types.Char ww key of wild1 {
                        [] -> $j GHC.Prim.void#
                        : ipv ipv1 -> Cipher.caesarEncode_go key text }
                   GHC.Types.True
                   -> case key of wild1 {
                        [] -> $j GHC.Prim.void#
                        : ipv ipv1 -> Cipher.caesarEncode_go wild1 text } } }) -}
6b5b92dd87e551ebe5583ce8504e11c1
  caesarEncodeRandom ::
    GHC.Base.String -> GHC.Types.IO (GHC.Base.String, GHC.Base.String)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Cipher.caesarEncodeRandom1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <(GHC.Base.String, GHC.Base.String)>_R)) -}
fc83adbac7f1599e2770cb861c1215ff
  caesarEncodeRandom1 ::
    GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (GHC.Base.String, GHC.Base.String) #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (text :: GHC.Base.String)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case System.Random.theStdGen
                        `cast`
                      (GHC.IORef.N:IORef[0] <System.Random.StdGen>_N) of wild { GHC.STRef.STRef r# ->
                 case GHC.Prim.atomicModifyMutVar#
                        @ GHC.Prim.RealWorld
                        @ System.Random.StdGen
                        @ (System.Random.StdGen, System.Random.StdGen)
                        @ System.Random.StdGen
                        r#
                        System.Random.newStdGen2
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of b1 { System.Random.StdGen ipv2 ipv3 ->
                 (# ipv,
                    let {
                      alphabetCharacters :: [GHC.Types.Char] = Cipher.$wgo b1 100#
                    } in
                    (alphabetCharacters,
                     Cipher.caesarEncode alphabetCharacters text) #) } } }) -}
3517dfbf58b95784dcdf8761f8831942
  caesarEncode_go ::
    [GHC.Types.Char] -> [GHC.Types.Char] -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

