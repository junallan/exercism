
==================== FINAL INTERFACE ====================
2017-03-24 12:38:57.6191094 UTC

interface clock-0.0.0-54SCCZ1Dwk81ErhdhB6NoV:Clock 8002
  interface hash: 1e28dac7803004a0b6ebd40bf6259c38
  ABI hash: 98577f286a23e9698f699d459422b7e9
  export-list hash: 4e9dc5a0bb793162602f36bb6fc4dc77
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 50be09f6ae5701bb586bc6db9bc9ce26
  sig of: Nothing
  used TH splices: False
  where
exports:
  Clock.clockHour
  Clock.clockMin
  Clock.fromHourMin
  Clock.toString
module dependencies:
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:GHC.Base 4caea1123ecf4b46e27cbccd6d279377
import  -/  base-4.9.1.0:GHC.Num 38b8aac8807c096c7f3ca3c1eff02939
import  -/  base-4.9.1.0:GHC.Real b88ae4a48c079652623073a5bbf5c9b0
import  -/  base-4.9.1.0:GHC.Show eca5834daba3b6a2bbbe64ab52056707
import  -/  base-4.9.1.0:Prelude 74b3e204395920329f6de9d97206abe9
import  -/  ghc-prim-0.5.0.0:GHC.Classes 16d48e012d23eaef9bca91ccdd572c02
09e3ec427a900c9e27b0c24b4807413a
  $fEqClock :: GHC.Classes.Eq Clock.Clock
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Clock.Clock Clock.$fEqClock_$c== Clock.$fEqClock_$c/= -}
09e3ec427a900c9e27b0c24b4807413a
  $fEqClock_$c/= :: Clock.Clock -> Clock.Clock -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Clock.Clock) (w1 :: Clock.Clock) ->
                 case w of ww { Clock.Clock ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Clock.Clock ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Clock.$w$c/= ww4 ww2 ww9 ww7 } } } }) -}
09e3ec427a900c9e27b0c24b4807413a
  $fEqClock_$c== :: Clock.Clock -> Clock.Clock -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Clock.Clock) (w1 :: Clock.Clock) ->
                 case w of ww { Clock.Clock ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Clock.Clock ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Clock.$w$c== ww4 ww2 ww9 ww7 } } } }) -}
09e3ec427a900c9e27b0c24b4807413a
  $fNumClock :: GHC.Num.Num Clock.Clock
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Clock.Clock
                  Clock.$fNumClock_$c+
                  Clock.$fNumClock_$c-
                  Clock.$fNumClock_$c*
                  Clock.$fNumClock_$cnegate
                  Clock.$fNumClock_$cabs
                  Clock.$fNumClock_$csignum
                  Clock.$fNumClock_$cfromInteger -}
afdda2c519e8b0a9d5554a92862acdc3
  $fNumClock1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
09e3ec427a900c9e27b0c24b4807413a
  $fNumClock2 :: Clock.Clock
  {- Unfolding: (case Clock.$w$cfromInteger
                        Clock.$fNumClock3 of ww { (#,#) ww1 ww2 ->
                 Clock.Clock ww1 ww2 }) -}
1b22e986cf85c04ae7fa3928f779412f
  $fNumClock3 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
09e3ec427a900c9e27b0c24b4807413a
  $fNumClock_$c* :: Clock.Clock -> Clock.Clock -> Clock.Clock
  {- Strictness: x -}
09e3ec427a900c9e27b0c24b4807413a
  $fNumClock_$c+ :: Clock.Clock -> Clock.Clock -> Clock.Clock
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)S(S)),1*U(1*U(U),1*U(U))><S(S(S)S(S)),1*U(1*U(U),1*U(U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Clock.Clock) (w1 :: Clock.Clock) ->
                 case w of ww { Clock.Clock ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 case w1 of ww7 { Clock.Clock ww8 ww9 ->
                 case ww8 of ww10 { GHC.Types.I# ww11 ->
                 case ww9 of ww12 { GHC.Types.I# ww13 ->
                 case GHC.Prim.+#
                        (GHC.Prim.*# (GHC.Prim.+# ww4 ww11) 60#)
                        (GHC.Prim.+# ww6 ww13) of wild {
                   DEFAULT
                   -> Clock.Clock
                        (case GHC.Classes.divInt# wild 60# of ww14 { DEFAULT ->
                         case GHC.Classes.modInt# ww14 24# of ww15 { DEFAULT ->
                         GHC.Types.I# ww15 } })
                        (case GHC.Classes.modInt# wild 60# of ww14 { DEFAULT ->
                         GHC.Types.I# ww14 })
                   1440#
                   -> Clock.Clock
                        Clock.$fNumClock1
                        Clock.$fNumClock1 } } } } } } }) -}
09e3ec427a900c9e27b0c24b4807413a
  $fNumClock_$c- :: Clock.Clock -> Clock.Clock -> Clock.Clock
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Clock.Clock) (y :: Clock.Clock) ->
                 Clock.$fNumClock_$c+ x (Clock.$fNumClock_$cnegate y)) -}
09e3ec427a900c9e27b0c24b4807413a
  $fNumClock_$cabs :: Clock.Clock -> Clock.Clock
  {- Strictness: x -}
09e3ec427a900c9e27b0c24b4807413a
  $fNumClock_$cfromInteger :: GHC.Integer.Type.Integer -> Clock.Clock
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Integer.Type.Integer) ->
                 case Clock.$w$cfromInteger w of ww { (#,#) ww1 ww2 ->
                 Clock.Clock ww1 ww2 }) -}
09e3ec427a900c9e27b0c24b4807413a
  $fNumClock_$cnegate :: Clock.Clock -> Clock.Clock
  {- Arity: 1, Strictness: <S(S(S)S(S)),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Clock.Clock) ->
                 case w of ww { Clock.Clock ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 Clock.$w$cnegate ww4 ww6 } } }) -}
09e3ec427a900c9e27b0c24b4807413a
  $fNumClock_$csignum :: Clock.Clock -> Clock.Clock
  {- Strictness: x -}
09e3ec427a900c9e27b0c24b4807413a
  $fShowClock :: GHC.Show.Show Clock.Clock
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Clock.Clock
                  Clock.$fShowClock_$cshowsPrec
                  Clock.$fShowClock_$cshow
                  Clock.$fShowClock_$cshowList -}
09e3ec427a900c9e27b0c24b4807413a
  $fShowClock1 :: Clock.Clock -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: Clock.Clock) (w1 :: GHC.Base.String) ->
                 case w of ww { Clock.Clock ww1 ww2 ->
                 Clock.$w$cshowsPrec 0# ww1 ww2 w1 }) -}
66656e826920c405f7c60578911a486a
  $fShowClock2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Clock {"#) -}
9d224385fd6aaac970db30d43f6d6785
  $fShowClock3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
fe5af5d339977e64cf0ec40a81b7cf78
  $fShowClock4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "minutes = "#) -}
8fa5a804b7b94f46aa479e421d4363ab
  $fShowClock5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
6d47b1f0f8ac6790a4e6d1db1bfa8828
  $fShowClock6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "hours = "#) -}
09e3ec427a900c9e27b0c24b4807413a
  $fShowClock_$cshow :: Clock.Clock -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(U),1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Clock.Clock) ->
                 Clock.$fShowClock_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
09e3ec427a900c9e27b0c24b4807413a
  $fShowClock_$cshowList :: [Clock.Clock] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Clock.Clock
                   Clock.$fShowClock1) -}
09e3ec427a900c9e27b0c24b4807413a
  $fShowClock_$cshowsPrec ::
    GHC.Types.Int -> Clock.Clock -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U(1*U(U),1*U(U))><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Clock.Clock)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Clock.Clock ww3 ww4 ->
                 Clock.$w$cshowsPrec ww1 ww3 ww4 w2 } }) -}
c0dd8f7338c37b3aebb66033a77d0947
  $tc'Clock :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15594480008458557093##
                   17678443996667880559##
                   Clock.$trModule
                   Clock.$tc'Clock1) -}
ea16dcd1119ab80de59e2d92507ba5e3
  $tc'Clock1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Clock"#) -}
57e8fb79d9034c18e7a18cfec23e63b8
  $tcClock :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3206619918525963180##
                   3124728442416667961##
                   Clock.$trModule
                   Clock.$trModule1) -}
1c48c0b564350dec2ccf41b37a79c67a
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Clock.$trModule2 Clock.$trModule1) -}
5fa371f0e7d2c0324ac0f8d667df33ee
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Clock"#) -}
5f179d666b741d5b1677a2f266f76d87
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "clock-0.0.0-54SCCZ1Dwk81ErhdhB6NoV"#) -}
f9288437a10d106a65a9b597787d4d01
  $w$c/= ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><S,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Types.Int) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww ww2) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case ww1 of wild1 { GHC.Types.I# x ->
                      case ww3 of wild2 { GHC.Types.I# y ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# x y) of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
99b340a4d1d0f6a82ffd8c99c5b38b3e
  $w$c== ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><S,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Types.Int) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww ww2) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> GHC.Classes.eqInt ww1 ww3 }) -}
748ace1021e2a2a3594c144529f2c590
  $w$cfromInteger ::
    GHC.Integer.Type.Integer -> (# GHC.Types.Int, GHC.Types.Int #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (w :: GHC.Integer.Type.Integer) ->
                 case GHC.Integer.Type.integerToInt w of wild {
                   DEFAULT
                   -> (# case GHC.Classes.divInt# wild 60# of ww4 { DEFAULT ->
                         case GHC.Classes.modInt# ww4 24# of ww2 { DEFAULT ->
                         GHC.Types.I# ww2 } },
                         case GHC.Classes.modInt# wild 60# of ww2 { DEFAULT ->
                         GHC.Types.I# ww2 } #)
                   1440# -> (# Clock.$fNumClock1, Clock.$fNumClock1 #) }) -}
09e3ec427a900c9e27b0c24b4807413a
  $w$cnegate :: GHC.Prim.Int# -> GHC.Prim.Int# -> Clock.Clock
  {- Arity: 2, Strictness: <S,U><S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (ww1 :: GHC.Prim.Int#) ->
                 case GHC.Prim.-#
                        1440#
                        (GHC.Prim.+# (GHC.Prim.*# ww 60#) ww1) of wild {
                   DEFAULT
                   -> Clock.Clock
                        (case GHC.Classes.divInt# wild 60# of ww4 { DEFAULT ->
                         case GHC.Classes.modInt# ww4 24# of ww2 { DEFAULT ->
                         GHC.Types.I# ww2 } })
                        (case GHC.Classes.modInt# wild 60# of ww2 { DEFAULT ->
                         GHC.Types.I# ww2 })
                   0# -> Clock.$fNumClock2
                   1440# -> Clock.Clock Clock.$fNumClock1 Clock.$fNumClock1 }) -}
16976ec352d6ba96179d7b6ca2c1804c
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <S,U><L,1*U(U)><L,1*U(U)><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int)
                   (w :: GHC.Base.String) ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,1*U> -}
                   = \ (x :: GHC.Base.String)[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Clock.$fShowClock6
                       (case ww1 of ww3 { GHC.Types.I# ww4 ->
                        case GHC.Show.$wshowSignedInt
                               0#
                               ww4
                               (GHC.Base.++
                                  @ GHC.Types.Char
                                  Clock.$fShowClock5
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     Clock.$fShowClock4
                                     (case ww2 of ww5 { GHC.Types.I# ww6 ->
                                      case GHC.Show.$wshowSignedInt
                                             0#
                                             ww6
                                             (GHC.Base.++
                                                @ GHC.Types.Char
                                                Clock.$fShowClock3
                                                x) of ww7 { (#,#) ww8 ww9 ->
                                      GHC.Types.:
                                        @ GHC.Types.Char
                                        ww8
                                        ww9 } }))) of ww5 { (#,#) ww6 ww7 ->
                        GHC.Types.: @ GHC.Types.Char ww6 ww7 } })
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> GHC.Base.++ @ GHC.Types.Char Clock.$fShowClock2 (g w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Clock.$fShowClock2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 w))) }) -}
336d4f803970c4eb3ac1c512a1687c44
  $wtoString :: GHC.Prim.Int# -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (ww1 :: GHC.Types.Int) ->
                 let {
                   n :: [GHC.Types.Char]
                   = GHC.CString.unpackAppendCString#
                       ":"#
                       (case ww1 of wild { GHC.Types.I# x ->
                        case GHC.Prim.tagToEnum#
                               @ GHC.Types.Bool
                               (GHC.Prim.>=# x 0#) of wild1 {
                          GHC.Types.False
                          -> case GHC.Show.$wshowSignedInt
                                    0#
                                    x
                                    (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                             GHC.Types.: @ GHC.Types.Char ww5 ww6 }
                          GHC.Types.True
                          -> case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.<# x 10#) of wild2 {
                               GHC.Types.False
                               -> case GHC.Show.$wshowSignedInt
                                         0#
                                         x
                                         (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                                  GHC.Types.: @ GHC.Types.Char ww5 ww6 }
                               GHC.Types.True
                               -> GHC.CString.unpackAppendCString#
                                    "0"#
                                    (case GHC.Show.$wshowSignedInt
                                            0#
                                            x
                                            (GHC.Types.[]
                                               @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                                     GHC.Types.: @ GHC.Types.Char ww5 ww6 }) } } })
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0#) of wild {
                   GHC.Types.False
                   -> case GHC.Show.$wshowSignedInt
                             0#
                             ww
                             (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                      GHC.Base.++
                        @ GHC.Types.Char
                        (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                        n }
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<# ww 10#) of wild1 {
                        GHC.Types.False
                        -> case GHC.Show.$wshowSignedInt
                                  0#
                                  ww
                                  (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                             n }
                        GHC.Types.True
                        -> GHC.CString.unpackAppendCString#
                             "0"#
                             (case GHC.Show.$wshowSignedInt
                                     0#
                                     ww
                                     (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                              GHC.Base.++
                                @ GHC.Types.Char
                                (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                                n }) } }) -}
09e3ec427a900c9e27b0c24b4807413a
  data Clock
    = Clock {hours :: GHC.Types.Int, minutes :: GHC.Types.Int}
1a2948f7182d37bc8d24e2a5d379c7f2
  clockHour :: Clock.Clock -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U(U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Clock.Clock) ->
                 case ds of wild { Clock.Clock h ds1 -> h }) -}
caf9357d29e774fb2938d5231dacd333
  clockMin :: Clock.Clock -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Clock.Clock) ->
                 case ds of wild { Clock.Clock ds1 m -> m }) -}
90becc4940adf9b3825ac3845f80554a
  fromHourMin :: GHC.Types.Int -> GHC.Types.Int -> Clock.Clock
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (hour :: GHC.Types.Int) (min :: GHC.Types.Int) ->
                 case hour of wild { GHC.Types.I# x ->
                 case min of wild1 { GHC.Types.I# y ->
                 Clock.$fNumClock_$cfromInteger
                   (GHC.Integer.Type.smallInteger
                      (GHC.Prim.+# (GHC.Prim.*# x 60#) y)) } }) -}
3cdd129af7d3b2ebaac18ed1d3f1371a
  hours :: Clock.Clock -> GHC.Types.Int
  RecSel Left Clock.Clock
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U(U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Clock.Clock) ->
                 case ds of wild { Clock.Clock ds1 ds2 -> ds1 }) -}
c11368eab388f78ddda5bb18b1ded5b8
  minutes :: Clock.Clock -> GHC.Types.Int
  RecSel Left Clock.Clock
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Clock.Clock) ->
                 case ds of wild { Clock.Clock ds1 ds2 -> ds2 }) -}
2e431b00f668eaf5fccbba94a6a19232
  toString :: Clock.Clock -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Clock.Clock) ->
                 case w of ww { Clock.Clock ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 Clock.$wtoString ww4 ww2 } }) -}
instance [safe] GHC.Classes.Eq [Clock.Clock] = Clock.$fEqClock
instance [safe] GHC.Num.Num [Clock.Clock] = Clock.$fNumClock
instance [safe] GHC.Show.Show [Clock.Clock] = Clock.$fShowClock
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

