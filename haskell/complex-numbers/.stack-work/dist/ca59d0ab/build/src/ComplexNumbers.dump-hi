
==================== FINAL INTERFACE ====================
2017-11-09 02:26:27.1397655 UTC

interface complex-numbers-1.0.0.1-8JgwOyf8WhxGBuOr0SRUpi:ComplexNumbers 8002
  interface hash: 1e1c8ef0e96349593defc8be46f5896a
  ABI hash: 9bedb6455d9c78ccb145640ea320256b
  export-list hash: 4d8bb6da3c3e154745201c86162c5444
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 50be09f6ae5701bb586bc6db9bc9ce26
  sig of: Nothing
  used TH splices: False
  where
exports:
  ComplexNumbers.abs
  ComplexNumbers.add
  ComplexNumbers.complex
  ComplexNumbers.conjugate
  ComplexNumbers.div
  ComplexNumbers.imaginary
  ComplexNumbers.mul
  ComplexNumbers.real
  ComplexNumbers.sub
  ComplexNumbers.Complex
module dependencies:
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:GHC.Base 4caea1123ecf4b46e27cbccd6d279377
import  -/  base-4.9.1.0:GHC.Float b620368aab866c2bb9d3a0a459566b84
import  -/  base-4.9.1.0:GHC.Num 38b8aac8807c096c7f3ca3c1eff02939
import  -/  base-4.9.1.0:GHC.Real b88ae4a48c079652623073a5bbf5c9b0
import  -/  base-4.9.1.0:GHC.Show eca5834daba3b6a2bbbe64ab52056707
import  -/  base-4.9.1.0:Prelude 74b3e204395920329f6de9d97206abe9
import  -/  ghc-prim-0.5.0.0:GHC.Classes 16d48e012d23eaef9bca91ccdd572c02
2dca0ba5310c807f1c01337fa0fba234
  $fEqComplex ::
    GHC.Classes.Eq a => GHC.Classes.Eq (ComplexNumbers.Complex a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dEq :: GHC.Classes.Eq a).
                  @ (ComplexNumbers.Complex a)
                  (ComplexNumbers.$fEqComplex_$c== @ a $dEq)
                  (ComplexNumbers.$fEqComplex_$c/= @ a $dEq) -}
2dca0ba5310c807f1c01337fa0fba234
  $fEqComplex_$c/= ::
    GHC.Classes.Eq a =>
    ComplexNumbers.Complex a
    -> ComplexNumbers.Complex a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S(S),1*U(1*U(U,U))><S(S),1*U(1*U(U,U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Classes.Eq a)
                   (w1 :: ComplexNumbers.Complex a)
                   (w2 :: ComplexNumbers.Complex a) ->
                 case w1 of ww { ComplexNumbers.Complex ww1 ->
                 case ww1 of ww2 { (,) ww3 ww4 ->
                 case w2 of ww5 { ComplexNumbers.Complex ww6 ->
                 case ww6 of ww7 { (,) ww8 ww9 ->
                 ComplexNumbers.$w$c/= @ a w ww3 ww4 ww8 ww9 } } } }) -}
2dca0ba5310c807f1c01337fa0fba234
  $fEqComplex_$c== ::
    GHC.Classes.Eq a =>
    ComplexNumbers.Complex a
    -> ComplexNumbers.Complex a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S(S),1*U(1*U(U,U))><S(S),1*U(1*U(U,U))>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (ds :: ComplexNumbers.Complex a)
                   (ds1 :: ComplexNumbers.Complex a) ->
                 case ds of wild { ComplexNumbers.Complex a1 ->
                 case ds1 of wild1 { ComplexNumbers.Complex b1 ->
                 GHC.Classes.$fEq(,)_$c== @ a @ a $dEq $dEq a1 b1 } }) -}
2dca0ba5310c807f1c01337fa0fba234
  $fShowComplex ::
    GHC.Show.Show a => GHC.Show.Show (ComplexNumbers.Complex a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (ComplexNumbers.Complex a)
                  (ComplexNumbers.$fShowComplex_$cshowsPrec @ a $dShow)
                  (ComplexNumbers.$fShowComplex_$cshow @ a $dShow)
                  (ComplexNumbers.$fShowComplex_$cshowList @ a $dShow) -}
adce5b617c61254e6722c6a834931e1f
  $fShowComplex1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
09589c119d83244a3b994ae32e16a5b9
  $fShowComplex2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Complex "#) -}
b39d6bd46dcfebde4a814b28f2f19f90
  $fShowComplex3 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows4
                   (GHC.Types.[] @ GHC.Types.Char)) -}
2dca0ba5310c807f1c01337fa0fba234
  $fShowComplex_$cshow ::
    GHC.Show.Show a => ComplexNumbers.Complex a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><S,1*U(1*U(U,U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Show.Show a) (w1 :: ComplexNumbers.Complex a) ->
                 case w1 of ww { ComplexNumbers.Complex ww1 ->
                 ComplexNumbers.$w$cshow @ a w ww1 }) -}
2dca0ba5310c807f1c01337fa0fba234
  $fShowComplex_$cshowList ::
    GHC.Show.Show a => [ComplexNumbers.Complex a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (eta :: [ComplexNumbers.Complex a])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (ComplexNumbers.Complex a)
                   (ComplexNumbers.$fShowComplex_$cshowsPrec
                      @ a
                      $dShow
                      ComplexNumbers.$fShowComplex1)
                   eta
                   eta1) -}
2dca0ba5310c807f1c01337fa0fba234
  $fShowComplex_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> ComplexNumbers.Complex a -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,U(C(C1(U)),A,A)><S(S),1*U(U)><S,1*U(1*U(U,U))><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: ComplexNumbers.Complex a)
                   (w3 :: GHC.Base.String) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { ComplexNumbers.Complex ww3 ->
                 ComplexNumbers.$w$cshowsPrec @ a w ww1 ww3 w3 } }) -}
260d99cd9ec01486c25e75cb7fb30eb6
  $tc'Complex :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2765322033355077799##
                   2352536721076874377##
                   ComplexNumbers.$trModule
                   ComplexNumbers.$tc'Complex1) -}
1649fdf11d48d5ebfe895017d7b7be0e
  $tc'Complex1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Complex"#) -}
ba49c9c6db189ba9d0c90cc3f2aff5f1
  $tcComplex :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15631511912259339431##
                   6189883377215775097##
                   ComplexNumbers.$trModule
                   ComplexNumbers.$tcComplex1) -}
32a79e918a0ffad2a8258349574ed06c
  $tcComplex1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Complex"#) -}
7d4023e606c1ef51e0755b9031110c79
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   ComplexNumbers.$trModule2
                   ComplexNumbers.$trModule1) -}
16a0a26698b215b5d5aa8e79b3a2f279
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "ComplexNumbers"#) -}
16c3735df55fb327cf624f9e07f0b4c6
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "complex-numbers-1.0.0.1-8JgwOyf8WhxGBuOr0SRUpi"#) -}
9115523609499bf48b14e9a4299f43a3
  $w$c/= :: GHC.Classes.Eq a => a -> a -> a -> a -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Classes.Eq a)
                   (ww :: a)
                   (ww1 :: a)
                   (ww2 :: a)
                   (ww3 :: a) ->
                 case GHC.Classes.== @ a w ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Classes.== @ a w ww1 ww3 of wild1 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } }) -}
73ed7912e347d3942b691c5f7fbcdcc2
  $w$cshow :: GHC.Show.Show a => (a, a) -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><L,1*U(U,U)>,
     Inline: [0],
     Unfolding: (\ @ a (w :: GHC.Show.Show a) (ww :: (a, a)) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   ComplexNumbers.$fShowComplex2
                   (case ww of ww1 { (,) ww2 ww3 ->
                    GHC.Types.:
                      @ GHC.Types.Char
                      GHC.Show.shows7
                      (GHC.Show.showsPrec
                         @ a
                         w
                         GHC.Show.shows22
                         ww2
                         (GHC.Types.:
                            @ GHC.Types.Char
                            GHC.Show.shows5
                            (GHC.Show.$fShow(,)_$sgo
                               ComplexNumbers.$fShowComplex3
                               (GHC.Show.showsPrec @ a w GHC.Show.shows22 ww3)
                               (GHC.Types.[] @ GHC.Show.ShowS)))) })) -}
09e046186b50688974b1b1a2dd7f43bf
  $w$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Prim.Int# -> (a, a) -> GHC.Base.String -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U(C(C1(U)),A,A)><S,U><L,1*U(U,U)><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: (a, a))
                   (w1 :: GHC.Base.String) ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String)[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       ComplexNumbers.$fShowComplex2
                       (case ww1 of ww2 { (,) ww3 ww4 ->
                        GHC.Types.:
                          @ GHC.Types.Char
                          GHC.Show.shows7
                          (GHC.Show.showsPrec
                             @ a
                             w
                             GHC.Show.shows22
                             ww3
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.shows5
                                (GHC.Show.$fShow(,)_$sgo
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x)
                                   (GHC.Show.showsPrec @ a w GHC.Show.shows22 ww4)
                                   (GHC.Types.[] @ GHC.Show.ShowS)))) })
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p w1
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 w1)) }) -}
98ccbb3ea48ceb45cba09b58bc36d6be
  $wabs :: GHC.Float.Floating a => a -> a -> a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLLC(S)LLLLLLLLLLLLLLLLLL),U(1*U,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Float.Floating a)
                   (ww :: a)
                   (ww1 :: a) ->
                 GHC.Float.sqrt
                   @ a
                   w
                   (let {
                      $dFractional :: GHC.Real.Fractional a = GHC.Float.$p1Floating @ a w
                    } in
                    let {
                      $dNum :: GHC.Num.Num a = GHC.Real.$p1Fractional @ a $dFractional
                    } in
                    GHC.Num.+
                      @ a
                      $dNum
                      (GHC.Num.* @ a $dNum ww ww)
                      (GHC.Num.* @ a $dNum ww1 ww1))) -}
1b3607814726396c78f94c0feacb9063
  $wdiv :: GHC.Real.Fractional a => a -> a -> a -> a -> (# (a, a) #)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U(1*U,C(C1(U)),A,A)><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Real.Fractional a)
                   (ww :: a)
                   (ww1 :: a)
                   (ww2 :: a)
                   (ww3 :: a) ->
                 (# let {
                      $dNum :: GHC.Num.Num a = GHC.Real.$p1Fractional @ a w
                    } in
                    (GHC.Real./
                       @ a
                       w
                       (GHC.Num.+
                          @ a
                          $dNum
                          (GHC.Num.* @ a $dNum ww ww2)
                          (GHC.Num.* @ a $dNum ww1 ww3))
                       (GHC.Num.+
                          @ a
                          $dNum
                          (GHC.Num.* @ a $dNum ww2 ww2)
                          (GHC.Num.* @ a $dNum ww3 ww3)),
                     GHC.Real./
                       @ a
                       w
                       (GHC.Num.-
                          @ a
                          $dNum
                          (GHC.Num.* @ a $dNum ww1 ww2)
                          (GHC.Num.* @ a $dNum ww ww3))
                       (GHC.Num.+
                          @ a
                          $dNum
                          (GHC.Num.* @ a $dNum ww2 ww2)
                          (GHC.Num.* @ a $dNum ww3 ww3))) #)) -}
d785281d7f4c22aa33e8f2cfec79d449
  $wmul :: GHC.Num.Num a => a -> a -> a -> a -> (# (a, a) #)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A)><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Num.Num a)
                   (ww :: a)
                   (ww1 :: a)
                   (ww2 :: a)
                   (ww3 :: a) ->
                 (# (GHC.Num.-
                       @ a
                       w
                       (GHC.Num.* @ a w ww ww2)
                       (GHC.Num.* @ a w ww1 ww3),
                     GHC.Num.+
                       @ a
                       w
                       (GHC.Num.* @ a w ww1 ww2)
                       (GHC.Num.* @ a w ww ww3)) #)) -}
2dca0ba5310c807f1c01337fa0fba234
  data Complex a = Complex (a, a)
1ae200cfb55fa678a8f8a382a8d30899
  abs :: GHC.Float.Floating a => ComplexNumbers.Complex a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLLC(S)LLLLLLLLLLLLLLLLLL),U(1*U,A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(S),1*U(1*U(U,U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: GHC.Float.Floating a)
                   (w1 :: ComplexNumbers.Complex a) ->
                 case w1 of ww { ComplexNumbers.Complex ww1 ->
                 case ww1 of ww2 { (,) ww3 ww4 ->
                 ComplexNumbers.$wabs @ a w ww3 ww4 } }) -}
bec2f7b47cf1e6465cf1c11d38721b18
  add ::
    GHC.Num.Num a =>
    ComplexNumbers.Complex a
    -> ComplexNumbers.Complex a -> ComplexNumbers.Complex a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A,A,A,A,A)><S(S),1*U(1*U(U,U))><S(S),1*U(1*U(U,U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Num.Num a)
                   (w1 :: ComplexNumbers.Complex a)
                   (w2 :: ComplexNumbers.Complex a) ->
                 case w1 of ww { ComplexNumbers.Complex ww1 ->
                 case ww1 of ww2 { (,) ww3 ww4 ->
                 case w2 of ww5 { ComplexNumbers.Complex ww6 ->
                 case ww6 of ww7 { (,) ww8 ww9 ->
                 ComplexNumbers.Complex
                   @ a
                   (GHC.Num.+ @ a w ww3 ww8, GHC.Num.+ @ a w ww4 ww9) } } } }) -}
7f602adce81722aa191659d7bb1b00b3
  complex :: (a, a) -> ComplexNumbers.Complex a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: (a, a)) ->
                 case ds of wild { (,) a1 b ->
                 ComplexNumbers.Complex @ a (a1, b) }) -}
969e491e9c9ef5d3f76ad30ccb39b95b
  conjugate ::
    GHC.Num.Num a =>
    ComplexNumbers.Complex a -> ComplexNumbers.Complex a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,1*C1(U),A,A,A)><S(S),1*U(1*U(U,U))>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (ds :: ComplexNumbers.Complex a) ->
                 case ds of wild { ComplexNumbers.Complex ds1 ->
                 case ds1 of wild1 { (,) a1 b ->
                 ComplexNumbers.Complex @ a (a1, GHC.Num.negate @ a $dNum b) } }) -}
014fce0b50d118f85ebfc20e7a23b1b7
  div ::
    GHC.Real.Fractional a =>
    ComplexNumbers.Complex a
    -> ComplexNumbers.Complex a -> ComplexNumbers.Complex a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(1*U,C(C1(U)),A,A)><S(S),1*U(1*U(U,U))><S(S),1*U(1*U(U,U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Real.Fractional a)
                   (w1 :: ComplexNumbers.Complex a)
                   (w2 :: ComplexNumbers.Complex a) ->
                 case w1 of ww { ComplexNumbers.Complex ww1 ->
                 case ww1 of ww2 { (,) ww3 ww4 ->
                 case w2 of ww5 { ComplexNumbers.Complex ww6 ->
                 case ww6 of ww7 { (,) ww8 ww9 ->
                 case ComplexNumbers.$wdiv
                        @ a
                        w
                        ww3
                        ww4
                        ww8
                        ww9 of ww10 { Unit# ww11 ->
                 ComplexNumbers.Complex @ a ww11 } } } } }) -}
fe9726ee76fb720d814e9413af91d5df
  imaginary :: GHC.Num.Num a => ComplexNumbers.Complex a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,A><S(S(LS)),1*U(1*U(A,1*U))>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (ds :: ComplexNumbers.Complex a) ->
                 case ds of wild { ComplexNumbers.Complex ds1 ->
                 case ds1 of wild1 { (,) a1 b -> b } }) -}
7774efe38cff6b7d589c04366588a9af
  mul ::
    GHC.Num.Num a =>
    ComplexNumbers.Complex a
    -> ComplexNumbers.Complex a -> ComplexNumbers.Complex a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(1*C1(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,A)><S(S),1*U(1*U(U,U))><S(S),1*U(1*U(U,U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Num.Num a)
                   (w1 :: ComplexNumbers.Complex a)
                   (w2 :: ComplexNumbers.Complex a) ->
                 case w1 of ww { ComplexNumbers.Complex ww1 ->
                 case ww1 of ww2 { (,) ww3 ww4 ->
                 case w2 of ww5 { ComplexNumbers.Complex ww6 ->
                 case ww6 of ww7 { (,) ww8 ww9 ->
                 case ComplexNumbers.$wmul
                        @ a
                        w
                        ww3
                        ww4
                        ww8
                        ww9 of ww10 { Unit# ww11 ->
                 ComplexNumbers.Complex @ a ww11 } } } } }) -}
2134b6e48c82e50c6c5304764d16ce4a
  real :: GHC.Num.Num a => ComplexNumbers.Complex a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,A><S(S(SL)),1*U(1*U(1*U,A))>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (ds :: ComplexNumbers.Complex a) ->
                 case ds of wild { ComplexNumbers.Complex ds1 ->
                 case ds1 of wild1 { (,) a1 b -> a1 } }) -}
aeac9a70232af989e5808f22003cfa4d
  sub ::
    GHC.Num.Num a =>
    ComplexNumbers.Complex a
    -> ComplexNumbers.Complex a -> ComplexNumbers.Complex a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A)><S(S),1*U(1*U(U,U))><S(S),1*U(1*U(U,U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Num.Num a)
                   (w1 :: ComplexNumbers.Complex a)
                   (w2 :: ComplexNumbers.Complex a) ->
                 case w1 of ww { ComplexNumbers.Complex ww1 ->
                 case ww1 of ww2 { (,) ww3 ww4 ->
                 case w2 of ww5 { ComplexNumbers.Complex ww6 ->
                 case ww6 of ww7 { (,) ww8 ww9 ->
                 ComplexNumbers.Complex
                   @ a
                   (GHC.Num.- @ a w ww3 ww8, GHC.Num.- @ a w ww4 ww9) } } } }) -}
instance [safe] GHC.Classes.Eq [ComplexNumbers.Complex]
  = ComplexNumbers.$fEqComplex
instance [safe] GHC.Show.Show [ComplexNumbers.Complex]
  = ComplexNumbers.$fShowComplex
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

